"""Tests to verify that all endpoints are documented in the README.

These tests use pytest-subtests to check that each endpoint in the FastAPI app
has corresponding documentation in the README, including:
- A section header for the endpoint
- A curl example showing how to call it
- A response example showing what to expect

This pattern follows the datasette-enrichments testing approach.
"""

from pathlib import Path

import pytest

from calendar_agent.calendar_server import app

# Path to README relative to this test file
README_PATH = Path(__file__).parent.parent / "README.md"

# Paths that are auto-generated by FastAPI and don't need documentation
EXCLUDED_PATHS = {
    "/openapi.json",
    "/docs",
    "/docs/oauth2-redirect",
    "/redoc",
}


def get_all_endpoints() -> list[tuple[str, str]]:
    """Extract all endpoints from the FastAPI app.

    Returns:
        List of (method, path) tuples for all documented endpoints
    """
    endpoints = []
    for route in app.routes:
        if hasattr(route, "path") and hasattr(route, "methods"):
            if route.path in EXCLUDED_PATHS:
                continue
            for method in route.methods:
                if method not in ("HEAD", "OPTIONS"):
                    endpoints.append((method, route.path))
    return sorted(endpoints)


def test_readme_exists():
    """Verify the README file exists."""
    assert README_PATH.exists(), f"README.md not found at {README_PATH}"


def test_all_endpoints_have_section_headers(subtests):
    """Verify each endpoint has a section header in the README.

    Each endpoint should have a header like:
    ### GET /health
    ### POST /calendars/{calendar_id}/events
    """
    readme_content = README_PATH.read_text()
    endpoints = get_all_endpoints()

    for method, path in endpoints:
        with subtests.test(endpoint=f"{method} {path}"):
            # Look for the endpoint header
            endpoint_header = f"### {method} {path}"
            assert endpoint_header in readme_content, (
                f"Endpoint {method} {path} is not documented in README.md. "
                f"Expected header: '{endpoint_header}'"
            )


def test_all_endpoints_have_curl_examples(subtests):
    """Verify each endpoint has a curl example in the README.

    GET endpoints should have:
        curl http://localhost:8082/path

    Other methods should have:
        curl -X POST http://localhost:8082/path
    """
    readme_content = README_PATH.read_text()
    endpoints = get_all_endpoints()

    for method, path in endpoints:
        with subtests.test(endpoint=f"{method} {path}"):
            # Build expected curl pattern
            # Replace path parameters with example values for matching
            example_path = path.replace("{calendar_id}", "primary")
            example_path = example_path.replace("{event_id}", "event123")

            if method == "GET":
                curl_pattern = f"curl http://localhost:8082{example_path}"
            else:
                curl_pattern = f"curl -X {method} http://localhost:8082{example_path}"

            # Check if curl example exists (allow for variations)
            has_curl = (
                curl_pattern in readme_content
                or f"curl -X {method}" in readme_content and path.split("{")[0] in readme_content
            )
            assert has_curl, (
                f"Endpoint {method} {path} does not have a curl example in README.md. "
                f"Expected something like: '{curl_pattern}'"
            )


def test_all_endpoints_have_response_examples(subtests):
    """Verify each endpoint has a response example in the README.

    Each endpoint section should contain either:
    - "Response:" followed by JSON
    - A code block with JSON response
    """
    readme_content = README_PATH.read_text()
    endpoints = get_all_endpoints()

    for method, path in endpoints:
        with subtests.test(endpoint=f"{method} {path}"):
            # Find the section for this endpoint
            endpoint_header = f"### {method} {path}"
            header_pos = readme_content.find(endpoint_header)

            if header_pos == -1:
                pytest.skip(f"Endpoint header not found: {endpoint_header}")

            # Find the next endpoint header (or end of file)
            next_header_pos = readme_content.find("### ", header_pos + len(endpoint_header))
            if next_header_pos == -1:
                next_header_pos = len(readme_content)

            # Extract the section content
            section_content = readme_content[header_pos:next_header_pos]

            # Check for response documentation
            has_response = (
                "Response:" in section_content
                or "```json" in section_content
                or '"success":' in section_content
            )
            assert has_response, (
                f"Endpoint {method} {path} does not have a response example in README.md. "
                "Expected 'Response:' or a JSON code block."
            )


def test_readme_has_required_sections(subtests):
    """Verify README has all required top-level sections."""
    readme_content = README_PATH.read_text()

    required_sections = [
        "# Calendar Agent",
        "## Overview",
        "## Setup",
        "## API Endpoints",
    ]

    for section in required_sections:
        with subtests.test(section=section):
            assert section in readme_content, (
                f"README.md is missing required section: '{section}'"
            )


def test_readme_documents_environment_variables(subtests):
    """Verify README documents required environment variables."""
    readme_content = README_PATH.read_text()

    required_env_vars = [
        "PROXY_URL",
        "PROXY_API_KEY",
        "LLM_URL",
    ]

    for env_var in required_env_vars:
        with subtests.test(env_var=env_var):
            assert env_var in readme_content, (
                f"README.md should document environment variable: {env_var}"
            )


def test_endpoint_count_matches():
    """Verify the number of documented endpoints matches the app."""
    endpoints = get_all_endpoints()

    # Expected endpoint count based on our implementation:
    # - 1 health
    # - 2 calendars (list, get)
    # - 5 events CRUD (list, create, get, update, patch, delete)
    # - 3 basic LLM (summarize, ask-about, batch-summarize)
    # - 3 calendar LLM (find-free-time, analyze-schedule, prepare-briefing)
    # - 2 operations (search, bulk-actions)
    expected_count = 17

    assert len(endpoints) == expected_count, (
        f"Expected {expected_count} endpoints, found {len(endpoints)}. "
        f"Endpoints: {endpoints}"
    )
